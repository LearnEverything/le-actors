{"initialI18nStore":{"en":{"common":{"__Debug message":"Hi, I am in English ðŸ‡¬ðŸ‡§"}}},"initialLanguage":"en","i18nServerInstance":null,"pageProps":{"pages":[],"filePath":"learnings","source":{"compiledSource":"\"use strict\";\n\nvar _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\n\nfunction MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Learnings (and failures!)\"), mdx(\"h2\", null, \"Isomorphic packages in TypeScript\"), mdx(\"h4\", null, \"The idea\"), mdx(\"p\", null, \"Meteor is smart enough to automatically differentiate server bundle from client bundle. This allows you to create isomorphic packages, meaning that you can share the exact same code between client and server.\"), mdx(\"p\", null, \"We tried this approach in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"v0.0.1\"), \", using Webpack. See the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"multi-env-demo\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"webpack\"), \" folders.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"multi-env-demo\\n|   index.client.ts\\n|   index.server.ts\\n\")), mdx(\"p\", null, \"At build time, we added some Webpack magic so that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"import \\\"@vulcanjs/multi-env-demo\"), \" is replaced by \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"import \\\"@vulcanjs/multi-env-demo/index.client\\\"\"), \" in the browser, and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"index.server\"), \" in the server build.\"), mdx(\"h3\", null, \"The problem\"), mdx(\"p\", null, \"What went wrong? The problem is that the concept of environment is foreign to the code itself. TypeScript and VS Code won't be able to tell whether you want to import \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"client\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"server\"), \", and it will necessarily break autocompletion.\"), mdx(\"p\", null, \"There don't seem to be any option in TypeScript to define new possible names or extension for folder \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"index\"), \", so you can't even specify an order (like \", \"[\\\"index\\\", \\\"index.server\\\", \\\"index.client\\\", \\\"main.js\\\"...]\", \" for instance). TS will simply ignore files that are not specifically named \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"index.ts\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"index.tsx\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"index.js\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"index.jsx\"), \".\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://stackoverflow.com/questions/61386301/webpack-metro-mainfiles-module-resolution-with-typescript\"\n  }, \"See this SO question for instance\")), mdx(\"h3\", null, \"Learning\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Magic isomorphism, with build time replacement, is bad for static analysis. You should not need to replace your \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"import\"), \" statement at build time. To be used carefully.\")), mdx(\"p\", null, \"Magic isomorphism is when you actually want to load a different piece of code depending on the environment, but hide this magic from the developer.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Muggle isomorphism, is perfectly fine.\")), mdx(\"p\", null, \"Muggle isomorphsim is when you write code that is perfectly working on both the server and the client.\"), mdx(\"p\", null, \"So, with the same example, if you need a client side only import, do \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"import \\\"@vulcanjs/multi-env-demo/client\\\"\"), \" (resp. server). If you have shared code, do create an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"index\"), \" file in your \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"multi-env-demo\"), \" packager and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"import \\\"@vulcanjs/multi-env-demo\\\"\"), \". No magic, make things explicit.\"), mdx(\"h3\", null, \"But it works in Blitz?\"), mdx(\"p\", null, \"If you have used the Next framework Blitz, you'll notice that \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/blitz-js/blitz/blob/rfc-architecture/rfc-docs/01-architecture.md#c-how-the-heck-does-that-work\"\n  }, \"they provide magic isomorphism for server queries\"), \". This patterns works because it is targeted a precise use case, where one environment owns the logic, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"server\"), \". The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"client\"), \" counterpart is simply an RPC call to the server function, it does not add any relevant logic. So the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"server\"), \" is considered as the default environment for static analysis.\"), mdx(\"p\", null, \"We did not follow this road, because we wanted to find a more generic pattern, more similar to hoiw Meteor works. In some case, client code can actually own the logic, for example when importing some non-SSR ready component. We can't safely consider the server as the \\\"default\\\" environment.\"), mdx(\"p\", null, \"(big thanks to @flybayer for explaining Blitz internals to us)\"));\n}\n\n;\nMDXContent.isMDXComponent = true;","renderedOutput":"<style data-emotion=\"css o2w69a-MuiTypography-root\">.css-o2w69a-MuiTypography-root{margin:0;font-family:\"Roboto\",\"Helvetica\",\"Arial\",sans-serif;font-weight:300;font-size:6rem;line-height:1.167;letter-spacing:-0.01562em;}</style><h1 class=\"MuiTypography-root MuiTypography-h1 css-o2w69a-MuiTypography-root\">Learnings (and failures!)</h1><style data-emotion=\"css 1sra7t5-MuiTypography-root\">.css-1sra7t5-MuiTypography-root{margin:0;font-family:\"Roboto\",\"Helvetica\",\"Arial\",sans-serif;font-weight:300;font-size:3.75rem;line-height:1.2;letter-spacing:-0.00833em;}</style><h2 class=\"MuiTypography-root MuiTypography-h2 css-1sra7t5-MuiTypography-root\">Isomorphic packages in TypeScript</h2><style data-emotion=\"css 5lbw0b-MuiTypography-root\">.css-5lbw0b-MuiTypography-root{margin:0;font-family:\"Roboto\",\"Helvetica\",\"Arial\",sans-serif;font-weight:400;font-size:2.125rem;line-height:1.235;letter-spacing:0.00735em;}</style><h4 class=\"MuiTypography-root MuiTypography-h4 css-5lbw0b-MuiTypography-root\">The idea</h4><style data-emotion=\"css ahj2mt-MuiTypography-root\">.css-ahj2mt-MuiTypography-root{margin:0;font-family:\"Roboto\",\"Helvetica\",\"Arial\",sans-serif;font-weight:400;font-size:1rem;line-height:1.5;letter-spacing:0.00938em;}</style><p class=\"MuiTypography-root MuiTypography-body1 css-ahj2mt-MuiTypography-root\">Meteor is smart enough to automatically differentiate server bundle from client bundle. This allows you to create isomorphic packages, meaning that you can share the exact same code between client and server.</p><style data-emotion=\"css ahj2mt-MuiTypography-root\">.css-ahj2mt-MuiTypography-root{margin:0;font-family:\"Roboto\",\"Helvetica\",\"Arial\",sans-serif;font-weight:400;font-size:1rem;line-height:1.5;letter-spacing:0.00938em;}</style><p class=\"MuiTypography-root MuiTypography-body1 css-ahj2mt-MuiTypography-root\">We tried this approach in <code>v0.0.1</code>, using Webpack. See the <code>multi-env-demo</code> and <code>webpack</code> folders.</p><pre><code>multi-env-demo\n|   index.client.ts\n|   index.server.ts\n</code></pre><style data-emotion=\"css ahj2mt-MuiTypography-root\">.css-ahj2mt-MuiTypography-root{margin:0;font-family:\"Roboto\",\"Helvetica\",\"Arial\",sans-serif;font-weight:400;font-size:1rem;line-height:1.5;letter-spacing:0.00938em;}</style><p class=\"MuiTypography-root MuiTypography-body1 css-ahj2mt-MuiTypography-root\">At build time, we added some Webpack magic so that <code>import &quot;@vulcanjs/multi-env-demo</code> is replaced by <code>import &quot;@vulcanjs/multi-env-demo/index.client&quot;</code> in the browser, and <code>index.server</code> in the server build.</p><style data-emotion=\"css gepadz-MuiTypography-root\">.css-gepadz-MuiTypography-root{margin:0;font-family:\"Roboto\",\"Helvetica\",\"Arial\",sans-serif;font-weight:400;font-size:3rem;line-height:1.167;letter-spacing:0em;}</style><h3 class=\"MuiTypography-root MuiTypography-h3 css-gepadz-MuiTypography-root\">The problem</h3><style data-emotion=\"css ahj2mt-MuiTypography-root\">.css-ahj2mt-MuiTypography-root{margin:0;font-family:\"Roboto\",\"Helvetica\",\"Arial\",sans-serif;font-weight:400;font-size:1rem;line-height:1.5;letter-spacing:0.00938em;}</style><p class=\"MuiTypography-root MuiTypography-body1 css-ahj2mt-MuiTypography-root\">What went wrong? The problem is that the concept of environment is foreign to the code itself. TypeScript and VS Code won&#x27;t be able to tell whether you want to import <code>client</code> or <code>server</code>, and it will necessarily break autocompletion.</p><style data-emotion=\"css ahj2mt-MuiTypography-root\">.css-ahj2mt-MuiTypography-root{margin:0;font-family:\"Roboto\",\"Helvetica\",\"Arial\",sans-serif;font-weight:400;font-size:1rem;line-height:1.5;letter-spacing:0.00938em;}</style><p class=\"MuiTypography-root MuiTypography-body1 css-ahj2mt-MuiTypography-root\">There don&#x27;t seem to be any option in TypeScript to define new possible names or extension for folder <code>index</code>, so you can&#x27;t even specify an order (like <!-- -->[&quot;index&quot;, &quot;index.server&quot;, &quot;index.client&quot;, &quot;main.js&quot;...]<!-- --> for instance). TS will simply ignore files that are not specifically named <code>index.ts</code>, <code>index.tsx</code>, <code>index.js</code>, <code>index.jsx</code>.</p><style data-emotion=\"css ahj2mt-MuiTypography-root\">.css-ahj2mt-MuiTypography-root{margin:0;font-family:\"Roboto\",\"Helvetica\",\"Arial\",sans-serif;font-weight:400;font-size:1rem;line-height:1.5;letter-spacing:0.00938em;}</style><p class=\"MuiTypography-root MuiTypography-body1 css-ahj2mt-MuiTypography-root\"><style data-emotion=\"css 778kay-MuiLink-root\">.css-778kay-MuiLink-root{-webkit-text-decoration:none;text-decoration:none;}.css-778kay-MuiLink-root:hover{-webkit-text-decoration:underline;text-decoration:underline;}</style><style data-emotion=\"css zr39bh-MuiTypography-root-MuiLink-root\">.css-zr39bh-MuiTypography-root-MuiLink-root{margin:0;color:#1976d2;-webkit-text-decoration:none;text-decoration:none;}.css-zr39bh-MuiTypography-root-MuiLink-root:hover{-webkit-text-decoration:underline;text-decoration:underline;}</style><a class=\"MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover css-zr39bh-MuiTypography-root-MuiLink-root\" href=\"https://stackoverflow.com/questions/61386301/webpack-metro-mainfiles-module-resolution-with-typescript\">See this SO question for instance</a></p><style data-emotion=\"css gepadz-MuiTypography-root\">.css-gepadz-MuiTypography-root{margin:0;font-family:\"Roboto\",\"Helvetica\",\"Arial\",sans-serif;font-weight:400;font-size:3rem;line-height:1.167;letter-spacing:0em;}</style><h3 class=\"MuiTypography-root MuiTypography-h3 css-gepadz-MuiTypography-root\">Learning</h3><ul><p>- <style data-emotion=\"css e784if-MuiTypography-root\">.css-e784if-MuiTypography-root{margin:0;font-family:\"Roboto\",\"Helvetica\",\"Arial\",sans-serif;font-weight:400;font-size:0.875rem;line-height:1.43;letter-spacing:0.01071em;}</style><span class=\"MuiTypography-root MuiTypography-body2 css-e784if-MuiTypography-root\">Magic isomorphism, with build time replacement, is bad for static analysis. You should not need to replace your <code>import</code> statement at build time. To be used carefully.</span></p></ul><style data-emotion=\"css ahj2mt-MuiTypography-root\">.css-ahj2mt-MuiTypography-root{margin:0;font-family:\"Roboto\",\"Helvetica\",\"Arial\",sans-serif;font-weight:400;font-size:1rem;line-height:1.5;letter-spacing:0.00938em;}</style><p class=\"MuiTypography-root MuiTypography-body1 css-ahj2mt-MuiTypography-root\">Magic isomorphism is when you actually want to load a different piece of code depending on the environment, but hide this magic from the developer.</p><ul><p>- <style data-emotion=\"css e784if-MuiTypography-root\">.css-e784if-MuiTypography-root{margin:0;font-family:\"Roboto\",\"Helvetica\",\"Arial\",sans-serif;font-weight:400;font-size:0.875rem;line-height:1.43;letter-spacing:0.01071em;}</style><span class=\"MuiTypography-root MuiTypography-body2 css-e784if-MuiTypography-root\">Muggle isomorphism, is perfectly fine.</span></p></ul><style data-emotion=\"css ahj2mt-MuiTypography-root\">.css-ahj2mt-MuiTypography-root{margin:0;font-family:\"Roboto\",\"Helvetica\",\"Arial\",sans-serif;font-weight:400;font-size:1rem;line-height:1.5;letter-spacing:0.00938em;}</style><p class=\"MuiTypography-root MuiTypography-body1 css-ahj2mt-MuiTypography-root\">Muggle isomorphsim is when you write code that is perfectly working on both the server and the client.</p><style data-emotion=\"css ahj2mt-MuiTypography-root\">.css-ahj2mt-MuiTypography-root{margin:0;font-family:\"Roboto\",\"Helvetica\",\"Arial\",sans-serif;font-weight:400;font-size:1rem;line-height:1.5;letter-spacing:0.00938em;}</style><p class=\"MuiTypography-root MuiTypography-body1 css-ahj2mt-MuiTypography-root\">So, with the same example, if you need a client side only import, do <code>import &quot;@vulcanjs/multi-env-demo/client&quot;</code> (resp. server). If you have shared code, do create an <code>index</code> file in your <code>multi-env-demo</code> packager and <code>import &quot;@vulcanjs/multi-env-demo&quot;</code>. No magic, make things explicit.</p><style data-emotion=\"css gepadz-MuiTypography-root\">.css-gepadz-MuiTypography-root{margin:0;font-family:\"Roboto\",\"Helvetica\",\"Arial\",sans-serif;font-weight:400;font-size:3rem;line-height:1.167;letter-spacing:0em;}</style><h3 class=\"MuiTypography-root MuiTypography-h3 css-gepadz-MuiTypography-root\">But it works in Blitz?</h3><style data-emotion=\"css ahj2mt-MuiTypography-root\">.css-ahj2mt-MuiTypography-root{margin:0;font-family:\"Roboto\",\"Helvetica\",\"Arial\",sans-serif;font-weight:400;font-size:1rem;line-height:1.5;letter-spacing:0.00938em;}</style><p class=\"MuiTypography-root MuiTypography-body1 css-ahj2mt-MuiTypography-root\">If you have used the Next framework Blitz, you&#x27;ll notice that <style data-emotion=\"css 778kay-MuiLink-root\">.css-778kay-MuiLink-root{-webkit-text-decoration:none;text-decoration:none;}.css-778kay-MuiLink-root:hover{-webkit-text-decoration:underline;text-decoration:underline;}</style><style data-emotion=\"css zr39bh-MuiTypography-root-MuiLink-root\">.css-zr39bh-MuiTypography-root-MuiLink-root{margin:0;color:#1976d2;-webkit-text-decoration:none;text-decoration:none;}.css-zr39bh-MuiTypography-root-MuiLink-root:hover{-webkit-text-decoration:underline;text-decoration:underline;}</style><a class=\"MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineHover css-zr39bh-MuiTypography-root-MuiLink-root\" href=\"https://github.com/blitz-js/blitz/blob/rfc-architecture/rfc-docs/01-architecture.md#c-how-the-heck-does-that-work\">they provide magic isomorphism for server queries</a>. This patterns works because it is targeted a precise use case, where one environment owns the logic, the <code>server</code>. The <code>client</code> counterpart is simply an RPC call to the server function, it does not add any relevant logic. So the <code>server</code> is considered as the default environment for static analysis.</p><style data-emotion=\"css ahj2mt-MuiTypography-root\">.css-ahj2mt-MuiTypography-root{margin:0;font-family:\"Roboto\",\"Helvetica\",\"Arial\",sans-serif;font-weight:400;font-size:1rem;line-height:1.5;letter-spacing:0.00938em;}</style><p class=\"MuiTypography-root MuiTypography-body1 css-ahj2mt-MuiTypography-root\">We did not follow this road, because we wanted to find a more generic pattern, more similar to hoiw Meteor works. In some case, client code can actually own the logic, for example when importing some non-SSR ready component. We can&#x27;t safely consider the server as the &quot;default&quot; environment.</p><style data-emotion=\"css ahj2mt-MuiTypography-root\">.css-ahj2mt-MuiTypography-root{margin:0;font-family:\"Roboto\",\"Helvetica\",\"Arial\",sans-serif;font-weight:400;font-size:1rem;line-height:1.5;letter-spacing:0.00938em;}</style><p class=\"MuiTypography-root MuiTypography-body1 css-ahj2mt-MuiTypography-root\">(big thanks to @flybayer for explaining Blitz internals to us)</p>","scope":{}}},"__N_SSG":true}